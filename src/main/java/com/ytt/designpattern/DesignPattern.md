# 设计模式
## 原则
## 结构型
### 外观模式 [**关系图**](image/12.jpg)
    其实就是为了方便客户的使用，把一群操作，封装成一个方法
### 适配器模式
    类适配器：
        通过继承实现。(继承的方式，调用别的类的方法)
        当我们要访问 3V 的时候，发现没有想要的方法，但是 另外的接口中 V5 有可用方法。
    对象适配器：
        通过组合实现。(成员变量的方式，调用别的类的方法)
### 组合模式
   >####透明组合模式 [**类关系图**](image/toumingmodel.jpg)
   
        优点：客户端统一对待，容器和叶子节点。
   
        缺点：不满足里氏替换原则。（使用父类声明，运行期是叶子节点，会报错异常）
   
   >####安全组合模式 [**类关系图**](image/safemodel.jpg)
   
   >#### 适用场景
   
   * 具有整体，部分的层次结构中，希望通过一种方式，忽略整体，和部分的差异，客户端可以一致的对待他们
   * 面向对象开发语言中一个树形结构。
   * 分离，叶子容器，和容器对象。
### 装饰模式 [**类关系图**](image/11.gif)
    动态地给一个对象增加一些额外的职责
    
   > 优点
   
        可以对一个对象进行多次装饰
   
   > 缺点
   
   > 使用场景
   
        (1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
        
        (2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。
   
### 代理模式 [**类图**](image/13.jpg)
   > [**静态代理**](dailimoshi/jingtaidaili) 
   
   > 动态代理
   
   >> [**JDK**](dailimoshi/jdkdaili)
   
        只能对实现接口的类进行代理。
        
   >> [**cglib**](dailimoshi/cglib)
   
        通过继承的方式进行代理
        
   >> 性能比较
        
        singleton，无需频繁创建代理对象的，比较适合cglib 代理技术。--spring4.x 企业应用开发实战
    
        